\documentclass[12pt]{article}

\usepackage[english]{babel}
\setlength{\parindent}{0pt} % tolgo indentazioni
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{amsmath,amssymb,amsfonts,mathrsfs,latexsym,stmaryrd}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{stackrel}
\usepackage{xcolor}
\usepackage{widetable}
\usepackage{graphicx}

% per multicolonna
\usepackage{multicol}

% per gli algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}

% per i grafi
\usepackage{tikz}
\usetikzlibrary{automata,positioning}

\newcommand{\A}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\Buchi}{\ensuremath{\mathcal{A} = (\mathcal{Q},A,\Delta,q_0,F)}\xspace}
\newcommand{\congAlpha}{\ensuremath{\cong_\alpha}\xspace}
\newcommand{\congAlphaM}{\ensuremath{\congAlpha^m}\xspace}
\newcommand{\buchi}{B\"uchi }

\title{Automatic System Verification\\Exercices}
\author{
        Cominato Enrico 137396 \\
                Department of Computer Science\\
        Univeristy of Udine
}
\date{\today}



\begin{document}
\maketitle

\section{Exercices on the automata's notes}
\subsection*{Esercizio 2.3}
\textit{Sia $\A$ l'automa dell'Esempio 2.2. Si consideri l'automa $\A'$ ottenuto da $\A$ rimuovendo lo stato $q_0$, e le transizioni in esso entranti e da esso uscenti, e facendo diventare $q_1$ il nuovo stato iniziale. Si stabilisca se $\A$ e $\A'$ riconoscono o meno lo stesso linguaggio} \\
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
Riporto di seguito i due grafi.
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state,initial,accepting] (q_0)   {$q_0$}; 
   	\node[state,accepting] (q_1) [right=of q_0]  {$q_1$};  
   	\node[state,accepting] (q_2) [right=of q_1] {$q_2$};
    \path[->] 
    (q_0) edge [loop above] node {b,c} (q_0)
          edge  node {a} (q_1)
    (q_1) edge [loop above] node {a} (q_1)
          edge [bend left] node {b,c} (q_2)
    (q_2) edge [bend left] node  {b,c} (q_1);
\end{tikzpicture}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial,accepting] (q_1)   {$q_1$};  
   \node[state,accepting] (q_2) [right=of q_1] {$q_2$};
    \path[->] 
    (q_1) edge [loop above] node {a} (q_1)
          edge [bend left] node {b,c} (q_2)
    (q_2) edge [bend left] node  {b,c} (q_1);
\end{tikzpicture}
\end{center}

I due linguaggi non sono uguali. Per esempio la $\omega -parola$ $babcabca...$ appartiene al primo dei due automi, ma non al secondo (da $q_1$ andiamo in $q_2$ ma da li possiamo leggere solo una b oppure una c)


\subsection*{Esercizio 2.4}
\textit{Si costruisca l'automa $\A'$ che riconosce la variante finita (linguaggio di parole finite) dell'Esempio 2.2}\\
Il linguaggio richiesto è il seguente:\\
\textit{L'insieme delle parole finite su $A=\{a,b,c\}$ tali che tra ogni
coppia di occorrenze consecutive di a esiste un numero pari di occorrenze di simboli diversi da a.}\\
Osservazione: una parola con una sola occorrenza di $a$ deve essere sempre accettata.\\
L'automa risultante quindi è lo stesso dell'esempio 2.2, solo che le run su questo automa sono finite.
% Esempio regex ^[bc]*(a([bc][bc])*)*[bc]?$
% per completare l'automa in modo che legga tutte le possibili parole basta aggiungere uno stato q_3 non terminale raggiungibile da q_2 con "a" e su cui si cicla all'infinito con {a,b,c}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state,initial,accepting] (q_0)   {$q_0$}; 
   	\node[state,accepting] (q_1) [right=of q_0]  {$q_1$};  
   	\node[state,accepting] (q_2) [right=of q_1] {$q_2$};
    \path[->] 
    (q_0) edge [loop above] node {b,c} (q_0)
          edge  node {a} (q_1)
    (q_1) edge [loop above] node {a} (q_1)
          edge [bend left] node {b,c} (q_2)
    (q_2) edge [bend left] node  {b,c} (q_1);
\end{tikzpicture}
\end{center}


\subsection*{Esercizio 2.5}
\textit{Sia W il linguaggio riconosciuto dall'automa \A' dell'Esercizio 2.4. Si caratterizzi il linguaggio $\overrightarrow{W}$.}

Riprendo la definizione di $\overrightarrow{W}$: 
$$\overrightarrow{W}=\{\alpha\in A^\omega \; t.c.\; \exists^\omega n \; \alpha(0,n) \in W\}$$
Sono quindi tutte quelle $\omega$-parole di cui ogni prefisso finito appartiene a $W$.
Analizziamo per casi:
\begin{itemize}
	\item la parola non ha neppure una $a$: in questo caso ogni suo prefisso appartiene a $W$ perchè le parole $(b|c),(b|c)^2,(b|c)^3,\ldots,(b|c)^n,\ldots \in W$
	\item la parola ha una sola occorrenza di $a$: anche in questo caso ogni suo prefisso appartiene a $W$ perchè:
	\begin{itemize}
		\item come visto nel punto precedente, fino a che non si incontra la lettera $a$ le parole appartengono a $W$
		\item dopo l'occorrenza di $a$, ancora tutti i prefissi appartengono a $W$, dato che tutte le parole finite con una sola occorrenza di $a$ appartengono a $W$
	\end{itemize}	
	\item infine tutti gli altri casi sono parole con un più di una occorrenza di $a$: dove abbiamo che ogni prefisso, o ricade in uno dei precedenti casi, oppure è una parola che tra ogni
coppia di occorrenze consecutive di a esiste un numero pari di occorrenze di simboli diversi da a e che quindi appartiene a $W$.
\end{itemize}

In questo caso abbiamo che $W^\omega = \overrightarrow{W}$.


\subsection*{Esercizio 2.7}
\paragraph*{Teorema 2.6}
\begin{enumerate}
	\item Se $V \subseteq A^*$ è regolare, allora $V^\omega$ è $\omega -regolare$
	\item Se $V \subseteq A^*$ è regolare e $L \subseteq A^\omega$ è $\omega -regolare$, allora $V\cdot L$ è $\omega -regolare$
	\item Se $L_1, L_2\subseteq A^*$ sono $\omega -regolari$, allora $L_1 \cup L_2$ e $L_1 \cap L_2$sono $\omega -regolari$
\end{enumerate}
\textit{Dimostrare le proprietà (2) e (3) del teorema}

Dimostro \textit{(2)}. Siano $\mathcal{A}, \mathcal{B}$ automi tali che $\mathcal{A}$ accetta V e $\mathcal{B}$ accetta L, allora possiamo costruire $\mathcal{C}$ unendo tutti gli stati finali di $\mathcal{A}$ con lo stato iniziale di $\mathcal{B}$. Otteniamo così un'automa che legge il linguaggio $V\cdot L$, quindi $V \cdot L$ è $\omega$-regolare.

Dimostro \textit{(3)}. Per quanto riguarda l'unione, prendiamo $\mathcal{A}, \mathcal{B}$ automi tali che $\mathcal{A}$ accetta $L_1$ e $\mathcal{B}$ accetta $L_2$. Costruiamo $\mathcal{C}$ unendo gli stati iniziali di $\mathcal{A}$ e $\mathcal{B}$. Abbiamo quindi che $\mathcal{C}$ accetta tutte le parole di $L_1 \cup L_2$. Sappiamo inoltre che i linguaggi $\omega$-regolari sono chiusi per complementazione, quindi possiamo riscrivere $L_1 \cap L_2 = \neg (\neg L_1 \cup \neg L_2)$ ed ottenere la chiusura per intersezione.

\subsection*{Esercizio 2.13}
\textit{Fornire un esempio di parola non definitivamente periodica}

Un esempio è: $$ ababbab^3ab^4ab^5...$$


\subsection*{Esercizio 2.16}
\textit{Dimostrare che una congruenza è una relazione di equivalenza invariante destra}

Invariante a destra significa che $\forall x,y,z \in A$, se $x \sim y$ allora $xz \sim yz$. Questo è sempre vero perchè, concatenando la stessa parola ad $x,y$ finiremo in un'unica classe di equivalenza.

\subsection*{Esercizio 2.19}
\textit{Dato un automa di \buchi $\Buchi$, dimostrare che, per ogni $s,s' \in \mathcal{Q}$, $W^F_{ss'}$ è regolare}

Un linguaggio è regolare se esiste un'automa in grado di accettarlo. Per poterlo accettare deve avere almeno uno stato finale. Quindi se eliminiamo dall'automa \A, tutti gli stati e le relazioni non interessate dai possibili cammini tra $s$ e $s'$ otteniamo un automa in grado di leggere solo $W^F_{ss'}$, e questo fa di lui un linguaggio regolare.

\subsection*{Esercizio 2.23}
\textit{Dimostrare che la relazione $\approx_A$ è una congruenza di indice finito}

Perchè $\approx_A$ sia una congruenza deve valere che $\forall u,u',v,v' \in A^*$ se $ u\approx_A v$ e $u' \approx_A v'$ allora $uu' \approx_A vv'$. Questo è vero perchè avendo $ u \approx_A v$ e $u' \approx_A v'$, allora $\exists t$ tale che:
\begin{itemize}
	\item $s \rightarrow_u t \Leftrightarrow s \rightarrow_v t$
	\item $s \rightarrow_u^F t \Leftrightarrow s \rightarrow_v^F t$
	\item $t \rightarrow_{u'} s' \Leftrightarrow t \rightarrow_{v'} s'$
	\item $t \rightarrow_{u'}^F s' \Leftrightarrow t \rightarrow_{v'}^F s'$
\end{itemize} 
Quindi abbiamo che $\forall s,s' \in Q$:
\begin{itemize}
	\item $s \rightarrow_{uu'} s' \Leftrightarrow s \rightarrow_{vv'} s'$
	\item $s \rightarrow_{uu'}^F s' \Leftrightarrow s \rightarrow_{vv'}^F s'$
\end{itemize} 
e quindi $uu' \approx_A vv'$.
Il resto della dimostrazione è già stata svolta negli appunti.

\subsection*{Esercizio 2.25}
\textit{Si dimostri che la relazione $\congAlpha$ è una relazione di equivalenza sui naturali di indice finito}

Riprendo la definizione di $\congAlpha$. Sia $\sim$ una congruenza su $A^*$ di indice finito. Sia $\alpha \in A^\omega$ e siano $k,k'$ posizioni. Diciamo che 
$k\congAlphaM k'$ ($k,k'$ si riuniscono in $m>k,k'$) se $\alpha(k,m)\sim\alpha(k',m)$. Diciamo che $k\congAlpha k'$ se esiste $m$ per cui $k \congAlphaM k'$.

Dimostro che è una relazione di equivalenza:
\begin{itemize}
	\item \textbf{Riflessività}: $\forall k \in \mathbb{N}$ è sempre vero che $k\congAlpha k$ perchè $k\congAlpha k \Leftrightarrow \exists m\;t.c.\;\alpha(k,m)\sim\alpha(k,m)$ e questo è vero $\forall k$ perchè $\sim$ è una relazione di equivalenza
	\item \textbf{Simmetria}: $\forall k,k' \in \mathbb{N}$ è sempre vero che $k\congAlpha k' \Rightarrow k' \congAlpha k$ perchè $k\congAlpha k' \Leftrightarrow \exists m\;t.c.\;\alpha(k,m)\sim\alpha(k',m)$. Dato che $\sim$ è una relazione di equivalenza allora vale che $\exists m\;t.c.\;\alpha(k',m)\sim\alpha(k,m)$, il che significa che $k' \congAlpha k$.
	\item \textbf{Transitività}: $\forall i,j,k \in \mathbb{N}$ è sempre vero che $i\congAlpha j$ e $j\congAlpha k \Rightarrow i \congAlpha k$, perchè $i\congAlpha j \Leftrightarrow \exists m\;t.c.\;\alpha(i,m)\sim\alpha(j,m)$ e $j\congAlpha k \Leftrightarrow \exists n\;t.c.\;\alpha(j,n)\sim\alpha(k,n)$. Senza perdere di generalità pongo $n>m$, quindi abbiamo che $\exists m\;t.c.\;\alpha(i,m)\sim\alpha(j,m)$ e $\alpha(j,m)\sim\alpha(k,m)$. Dato che $\sim$ è una relazione di equivalenza allora vale che $\exists m$ tale che $\alpha(i,m)\sim\alpha(j,m)$ e $\alpha(j,m)\sim\alpha(k,m) \Rightarrow \alpha(i,m)\sim\alpha(k,m)$, il che significa che $i \congAlpha k$. 
\end{itemize}

Dimostro che $\congAlpha$ ha indice finito. Dato che $\sim$ ha indice finito, per un $m$ fisso, ci troviamo in una situazione del genere:

% https://www.mathcha.io/editor
\begin{center}
	\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
	\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
	%uncomment if require: \path (0,739); %set diagram left start at 0, and has height of 739
	
	%Shape: Ellipse [id:dp9650618878961996] 
	\draw   (23.5,124.5) .. controls (23.5,63.47) and (95.13,14) .. (183.5,14) .. controls (271.87,14) and (343.5,63.47) .. (343.5,124.5) .. controls (343.5,185.53) and (271.87,235) .. (183.5,235) .. controls (95.13,235) and (23.5,185.53) .. (23.5,124.5) -- cycle ;
	%Straight Lines [id:da5240208167193734] 
	\draw    (135.5,20) -- (319,182.17) ;
	%Straight Lines [id:da29391365058759567] 
	\draw    (32.17,88) -- (219.67,232.17) ;
	%Straight Lines [id:da8926403422381457] 
	\draw    (51,185.5) -- (296.33,46.83) ;
	%Straight Lines [id:da020284257694958674] 
	\draw    (155,232.83) -- (339.67,96.17) ;
	%Shape: Free Drawing [id:dp14447012165158735] 
	\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=3] [line join = round][line cap = round] (66.5,76) .. controls (67.17,76) and (67.83,76) .. (68.5,76) ;
	%Shape: Free Drawing [id:dp8018216878137716] 
	\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=3] [line join = round][line cap = round] (125.5,110) .. controls (126.17,110) and (126.83,110) .. (127.5,110) ;
	%Shape: Free Drawing [id:dp5726072331827443] 
	\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=3] [line join = round][line cap = round] (176.5,138) .. controls (177.17,138) and (177.83,138) .. (178.5,138) ;
	%Shape: Free Drawing [id:dp6843798478967522] 
	\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=3] [line join = round][line cap = round] (164.5,168) .. controls (165.17,168) and (165.83,168) .. (166.5,168) ;
	
	% Text Node
	\draw (74,61.73) node [anchor=north west][inner sep=0.75pt]    {$\alpha ( k,m)$};
	% Text Node
	\draw (132.67,90.4) node [anchor=north west][inner sep=0.75pt]    {$\alpha ( k',m)$};
	% Text Node
	\draw (313.33,31.73) node [anchor=north west][inner sep=0.75pt]    {$\mathbb{N}$};
	% Text Node
	\draw (311.33,195.4) node [anchor=north west][inner sep=0.75pt]    {$\sim $};
	% Text Node
	\draw (183.67,119.57) node [anchor=north west][inner sep=0.75pt]    {$\alpha ( k'',m)$};
	% Text Node
	\draw (174.67,151.57) node [anchor=north west][inner sep=0.75pt]    {$\alpha ( k''',m)$};
	\end{tikzpicture}
\end{center}
Dove il numero di classi di equivalenza è limitato dal numero di classi di equivalenza di $\sim$, e sappiamo che $\sim$ ha un numero finito di classi di equivalenza, quindi anche $\congAlpha$ avrà un numero finito di classi di equivalenza.



\subsection*{Esercizio 2.44}
\textit{Dimostrare la chiusura della classe dei linguaggi riconosciuti dagli automi di \buchi deterministici rispetto alle operazioni di unione e intersezione}

Siano $\mathcal{A} = (\mathcal{Q_A},A,\Delta_A,q_{0A},F_A)$ e $\mathcal{B} = (\mathcal{Q_B},A,\Delta_B,q_{0B},F_B)$

\textbf{Unione}: Se assumiamo che $ \mathcal{Q_A} \cap \mathcal{Q_B} = \emptyset$ allora possiamo costruire l'automa unione $\mathcal{C}$ come segue:
\begin{itemize}
	\item $\mathcal{Q_C} = \mathcal{Q_A} \cup \mathcal{Q_B} \cup \{q_{0C}\}$
	\item $A$ rimane invariato
	\item $\Delta_C = \Delta_A \cup \Delta_B$
	\item $q_{0C}$ come nuovo stato iniziale, con le stesse relazioni di $q_{0A}$ e $q_{0B}$, finale nel caso che almeno uno tra $q_{0A}$ e $q_{0B}$ sia uno stato finale
	\item $F_C = F_A \cup F_B$
\end{itemize}
\textbf{Intersezione}: Costruiamo l'automa intersezione $\mathcal{C}$, partendo dal prodotto cartesiano degli stati:
\begin{itemize}
	\item $\mathcal{Q_C} = \mathcal{Q_A} \times \mathcal{Q_B} \times \{1,2\}$
	\item $A$ rimane invariato
	\item $\Delta_C = \Delta_1 \cup \Delta_2$ dove
	\begin{itemize}
		\item $\Delta_1 = \{ ((q_A,q_B,1),a,(q_{A}',q_{B}',i)) \; | \; (q_A,a,q_A') \in \Delta_A\;e\;(q_B,a,q_B') \in \Delta_B\;e\;se\;q_A\in F_A\;allora\;i=2\;altrimenti\;i=1\}$
		\item $\Delta_2 = \{ ((q_A,q_B,2),a,(q_{A}',q_{B}',i)) \; | \; (q_A,a,q_A') \in \Delta_A\;e\;(q_B,a,q_B') \in \Delta_B\;e\;se\;q_B\in F_B\;allora\;i=1\;altrimenti\;i=2\}$
	\end{itemize}
	\item $q_{0C} = (q_{0A},q_{0B},1)$
	\item $F_C = \{(q_a,q_b,2)\;|\;q_B \in F_B\}$
\end{itemize}
Per costruzione, $r_C=(q_{A}^0,q_{B}^0,i^0),(q_{A}^1,q_{B}^1,i^1),\ldots$ è un'esecuzione su $\mathcal{C}$ per la parola w se:
\begin{itemize}
	\item $r_A=q_{A}^0,q_{A}^1,\ldots$ è un'esecuzione su $\mathcal{A}$ per w
	\item $r_B=q_{B}^0,q_{B}^1,\ldots$ è un'esecuzione su $\mathcal{B}$ per w
\end{itemize}
$r_A$ e $r_B$ sono accettate se $r_C$ è la concatenazione di una serie infinita di segmenti finiti di stati 1 (stati con terza componente 1) e stati 2 (stati con terza componente 2) alternativamente. Questa sequenza esiste se $r_C$ è accettato da $\mathcal{A}$ 
\subsection*{Esercizio 2.46}
\textit{Sia $A=\{a,b\}$ e $L=\{\alpha \in A^\omega. \exists^{<\omega}\;n\;\alpha(n)=a\}$. Si costruisca un automa di \buchi non deterministico che riconosca il linguaggio $L$}
 
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$};  
   \node[state,accepting] (q_1) [right=of q_1] {$q_1$};
    \path[->] 
    (q_0) edge [loop above] node {a,b} (q_0)
          edge node {a,b} (q_1)
    (q_1) edge [loop above] node  {b} (q_1);
\end{tikzpicture}
\end{center}


\subsection*{Esercizio 2.48}
\textit{Sia $A=\{a,b\}$ e $L=\overrightarrow{\{b^*a^*\}}$. Si costruisca un automa di \buchi deterministico che riconosca il linguaggio $L$}

\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial,accepting] (q_0)   {$q_0$};  
   \node[state,accepting] (q_1) [right=of q_1] {$q_1$};
    \path[->] 
    (q_0) edge [loop above] node {b} (q_0)
          edge [bend left] node {a} (q_1)
    (q_1) edge [loop above] node  {a} (q_1)
    	  edge [bend left] node {b} (q_0);
\end{tikzpicture}
\end{center}


\subsection*{Esercizio 2.50}
\textit{Dimostrare che la classe degli $\omega$-linguaggi $\omega$-regolari coincide con la classe degli $\omega$-linguaggi riconosciuti dagli automi di Muller non deterministici}

Dato che un $\omega$-linguaggio per essere $\omega$-regolare deve essere accettato da un automa di \buchi, mi basta dimostrare l'equivalenza tra gli automi di \buchi non deterministici e quelli di Muller non deterministici.

Sia $\Buchi$ un automa di \buchi, possiamo costruire un automa di Muller: $\mathcal{M} = (\mathcal{Q},A,\Delta,q_0,\mathcal{F})$ dove $\mathcal{F} = \{ X | X \in 2^Q \land X \cap F \neq \emptyset\}$. Si può osservare che una $\omega$-parola viene accettata da $\A$ se e solo se passa infinite volte per uno stato finale. Quindi viene accettata anche da $\mathcal{M}$ perchè, presa una sua computazione $\sigma$, abbiamo che $In(\sigma) \cap F \neq \emptyset $ e $ In(\sigma) \in 2^Q \Rightarrow In(\sigma) \in \mathcal{F}$ quindi la stessa $\omega$-parola viene accettata da $\mathcal{F}$. Lo stesso ragionamento lo possiamo fare al contrario. Se una $\omega$-parola viene accettata da $\mathcal{M}$ allora $In(\sigma) \cap F \neq \emptyset $ quindi esiste una computazione che passa infinite volte per uno stato finale, quindi 
la stessa $\omega$-parola viene accettata da $\A$. 

\subsection*{Esercizio 2.57}
\textit{Dimostrare che l'insieme $W_V\subseteq A^*$ dei V-testimoni, con V classe di congruenza $\approx_\mathcal{A}$ è regolare}



\newpage
\section{Exercices of chapter 0 of Temporal Verification of Reactive Systems}
\subsection*{Problem 0.1}
\begin{center}
\begin{tabular}{|c|}
\hline
\textbf{out} x: \textbf{integer where} x = 0 \\

\parbox{4cm}{
  \begin{align*}
    l_0 &: \left[ \begin{aligned}
 		[l_1 &: \textbf{while }x \geq 0 \textbf{ do } l_2: x := x+1]\\ 
 		&\textbf{or} \\ 
 		[l_3 &: \textbf{await } x > 0] \\
		\end{aligned} \right]\\
 	l_4 &:
  \end{align*}}\\
Program S8 (strange behavior). \\
\hline
\end{tabular}
\end{center}

\textit{\textbf{a)} Identify the locations of this program as equivalence classes of labels. List the post-location of each of the statements.}

There are three classes:
\begin{itemize}
\item[$l_0$] = $\{ l_0,l_1,l_3 \} $
\item[$l_2$] = $\{ l_2 \} $
\item[$l_4$] = $\{ l_4 \} $
\end{itemize}

While the post-locations are:
\begin{itemize}
\item[$post(l_0)$] = $post(l_1)$ = $post(l_3)$ = $[ l_4 ] $
\item[$post(l_2)$] = $[ l_0 ] $
\end{itemize}

\textit{\textbf{b)} Show that this program has a terminating computation.}

The program can terminate because the post-location of the body of the while is the selection statement. So the await condition can be satisfied and this terminate the program.

\medskip
\textit{\textbf{c)} Define transitions and transition relations for this version of a WHILE statement.
Show that the version of program SB in which the while statement has been replaced by this WHILE statement has no terminating computation.}

Recall of the new WHILE statement:

$$ l_1: [WHILE\;c\;DO\;[l_2:S;\hat{l_2}]]; l_3: \textrm{ where } \hat{l_2} \nsim l_1$$

We can define its transitions $\tau_{l_1},\tau_{\hat{l_2}}$ and transition relations $\rho_{l_1},\rho_{\hat{l_2}}$ as follow:

\begin{itemize}
\item[$\rho_{l_1}:$] $\rho^T_{l_1} \lor \rho^F_{l_1}$ where 
	\begin{itemize}
		\item[$\rho^T_{l_1}:$] $move(l_1,l_2) \land c \land pres(Y)$ 
		\item[$\rho^F_{l_1}:$] $move(l_1,l_3) \land \neg c \land pres(Y)$
	\end{itemize}
\item[$\rho_{\hat{l_2}}:$] $\rho^T_{\hat{l_2}} \lor \rho^F_{\hat{l_2}}$ where 
	\begin{itemize}
		\item[$\rho^T_{\hat{l_2}}:$] $move(\hat{l_2},l_2) \land c \land pres(Y)$ 
		\item[$\rho^F_{\hat{l_2}}:$] $move(\hat{l_2},l_3) \land \neg c \land pres(Y)$
	\end{itemize}
\end{itemize}

As we can see, now the program cannot terminate anymore, because once in the WHILE loop, the transition $\rho^F_{\hat{l_2}}$ will be never satisfied.



\subsection*{Problem 0.2}
\begin{center}
\begin{tabular}{|ccc|}
\hline
\multicolumn{3}{|c|}{
\textbf{out} y: \textbf{integer where} y = 0
} \\
\multicolumn{3}{|c|}{
\textbf{local} x: \textbf{boolean where} x = T
} \\
\parbox{4cm}{\begin{align*}
      P_1 &:: \left[ \begin{aligned}
 		l_0 &: \textbf{while }x \textbf{ do } \\ 
 			& l_1: y:= y+1\\
 		l_2 &: \\
		\end{aligned} \right]\\
   \end{align*}}
   &
	$\Bigg{\|}$   
   &
   \parbox{4cm}{\begin{align*}
      P_2 &:: \left[ \begin{aligned}
 		m_0 &: x := F \\
 		m_1 &: \\
		\end{aligned} \right]\\
   \end{align*}}\\
   \multicolumn{3}{|c|}{Program ANY-NAT (computing any natural number).} \\\hline
\end{tabular}
\end{center}



\textit{\textbf{a)} Consider program ANY-NAT. Argue (informally) that this program always terminates. Also show that, for every natural number $n \geq 0$,
there exists a computation of ANY-NAT such that $y = n$ on termination.}

\medskip
The program terminates whenever $m_0$ is executed. The transition $\tau_{m_0}$ is always enabled and because of \textit{justice} requirement we know that, soon or later, it will be taken. Once executed $\rho^F_{l_0}$ is satisfied and control goes to $\pi = \{l_2,m_1\}$.
Furthermore, the justice requirement allow only a finite (but unbounded) number of transition $\tau_{l_0}$. So, $\forall n \in \mathbb{N}$ there exists a run where $\tau_{l_0}$ is taken $n$ times before $\tau_{m_0}$, leading to have $y=n$ on termination.

\medskip
\textit{\textbf{b)} Construct a program with a single process that exhibits a similar behavior;
that is, all of its computations terminate and, for each natural number n, there
exists a computation producing n.}

\begin{center}
\begin{tabular}{|c|}
\hline
	\textbf{out} y: \textbf{integer where} y = 0\\
	\textbf{local} x: \textbf{boolean where} x = T\\
	\parbox{4cm}{\begin{align*}
		l_0 &: \left[ \textbf{while }x \textbf{ do } l_1:
			\left[
			\begin{aligned}
 				[l_2 &: y:= y+1]\\ 
 					 & \textbf{or} \\
 				[l_3 &: x := F]
			\end{aligned} 
			\right]
			\right]\\
		l_4 &:
   \end{align*}}\\
\hline
\end{tabular}
\end{center}
This Program exibits the same behavior of the previus one:
\begin{itemize}
\item All of its computation terminates, because $\tau_{l_3}$ is always enabled and thank to the justice requirement we know that soon or later it will be taken and change the value of $x$ ending the cycle.
\item As the previous program, the number of iteration before the execution of $\tau_{l_3}$ is finite but unbounded, so $y$ could have any value in $\mathcal{N}$ at the end of the computation.
\end{itemize}

\medskip
\textit{\textbf{c)} Prove that no single-process program with only just transitions can have
the same behavior as ANY-NAT.}
This kind of program need:
\begin{itemize}
\item an incremental statement
\item a termination statement
\end{itemize}


\subsection*{Problem 0.3}
\textit{\textbf{a)} Consider the two statements
\begin{itemize}
\item[] $S_1 :: [x:=1;l_1: x:=2]$
\item[] $S_2 :: [x:=1;l_2: x:=x+1]$
\end{itemize}
and the context
$$P[S]:: l_0: [\textbf{out}\;x: \textbf{integer where}\;x = 0; S] \hat{l_0}:$$
Show that $P[S_1]$ and $P[S_2]$ are termination equivalent.}

$P[S_1]$ and $P[S_2]$ have the initial state with the same interpretation of the variable $x$ (equal to 0). They both have a single possible run, that is:
$$ P[S_1]: \langle \pi:[l_0],x:0\rangle \xrightarrow{l_0} \langle \pi:[l_1],x:1\rangle \xrightarrow{l_1} \langle \pi:[\hat{l_0}],x:2\rangle $$
$$ P[S_2]: \langle \pi:[l_0],x:0\rangle \xrightarrow{l_0} \langle \pi:[l_2],x:1\rangle \xrightarrow{l_2} \langle \pi:[\hat{l_0}],x:2\rangle $$
This lead to have ending states sharing the interpretation of variable $x$ equal to 2. Thus $P[S_1]$ and $P[S_2]$ are termination equivalent.

\medskip
\textit{\textbf{b)} Consider the preceding two statements and the context
$$Q[S]:: [\textbf{out}\;x: \textbf{integer where}\;x = 0; [[l_0: S; \hat{l_0}:] \parallel [m_0: x := 0 ; \hat{m_0}:]]].$$
Show that $Q[S_1]$ and $Q[S_2]$ are not termination equivalent. We may conclude that $S_1$ and $S_2$ are not congruent.}

$Q[S_1]$ and $Q[S_2]$ are not termination equivalent, because the are some computation that lead to different ending states, like:
\begin{align*}
Q[S_1]: &	\langle \pi:\{l_0,m_0\},x:0 \rangle \xrightarrow{l_0} 
			\langle \pi:\{l_1,m_0\},x:1 \rangle \xrightarrow{m_0} \\
		&	\langle \pi:\{l_1,\hat{m_0}\},x:0 \rangle \xrightarrow{l_1} 
			\langle \pi:\{\hat{l_0},\hat{m_0}\},x:2\rangle \\
Q[S_2]: &	\langle \pi:\{l_0,m_0\},x:0 \rangle \xrightarrow{l_0} 
			\langle \pi:\{l_2,m_0\},x:1 \rangle \xrightarrow{m_0} \\
		&	\langle \pi:\{l_2,\hat{m_0}\},x:0 \rangle \xrightarrow{l_2} 
			\langle \pi:\{\hat{l_0},\hat{m_0}\},x:1\rangle \\
\end{align*}

\medskip
\textit{\textbf{c)} Show the following congruence:}
\begin{enumerate}
\item $P::[S_1 \textbf{or} S_2] \approx Q::[S_2 \textbf{or} S_1]$: If $P$ selects $S_1$ (resp. $S_2$), also $Q$ can select $S_1$ (resp. $S_2$) and vice versa.
\item $[S_1 \parallel S_2] \approx [S_2 \parallel S_1]$: As the previous case, since there is no precondition to the parallel composition of $S_1$ and $S_2$, each transition on $P$ can be choose on $Q$.
\item $S \approx [S; \textbf{skip}]$: We know that \textbf{skip} always terminates, so $S$;\textbf{skip} terminates if and only if $S$ does. Moreover, \textbf{skip} does not alter the data (its data transformation is the identity).
\item $\textbf{await}\;c \approx \textbf{while}\;\neg c\;\textbf{do skip}$ While $c$ is false the programs loop forever. When $c$ is true, both programs terminates without altering the values of output variables.
\end{enumerate}

\medskip
\textit{\textbf{d)} Are the two statements:
$$ \textrm{\textbf{await} }x \textrm{ and \textbf{skip} }m: \textrm{\textbf{await} }x$$
congruent? Prove your answer.}

The statements are not congruent since there exist a context $P[S]$ like:
\begin{align*}
	P[S] &:: \left[ \begin{aligned}
 		\textrm{local }x &\textrm{ : boolean where }x = F \\ 
 			&[S\textrm{ or await }\neg x] \\
		\end{aligned} \right]
\end{align*}
where $P[\textrm{\textbf{await} }x]$ always terminates because $ \textrm{\textbf{await} }x$ is not enabled and $ \textrm{\textbf{await} } \neg x$ is selected, terminating the computation. While $P[\textrm{\textbf{skip} }m: \textrm{\textbf{await} }x]$ is always enabled, due to the \textbf{skip}, and if it is chosen, it leads to a non terminating computation.

\medskip
\textit{\textbf{e)} Let $y$ be a boolean variable. Which of the three following statements are congruent?
\begin{enumerate}
\item $y:=T$
\item $\textbf{if}\;y\;\textbf{then}\;y:=T\;\textbf{else}\;y:=T$
\item $\left[ [\textbf{await}\; y;\; y:=T]\;\textbf{or}\;[\textbf{await}\;\neg y;\; y:=T]\right]$
\end{enumerate}}
While \textit{1} and \textit{2} are equivalently enabled, the selection \textit{3} can be disregarded by a scheduler ensuring justice requirement, since the two await commands may be not continuously enabled. Consider the following context:
\begin{align*}
	P[S] &:: \left[ \begin{aligned}
 		&\textrm{local }x \textrm{ : boolean where }x = T \\ 
 		&\textrm{local }y \textrm{ : boolean where }y = F \\ 
 		&[S;x:=F] \parallel [\textrm{while }x\textrm{ do } y:= \neg y] \\
		\end{aligned} \right]
\end{align*}
While \textit{1} and \textit{2} always terminates in computations that ensure justice, with \textit{3} there exists a fair computation that stays forever in loop $\textrm{while }x\textrm{ do } y:= \neg y$, as the \textbf{await} commands are enabled in alternation.

\subsection*{Problem 0.4}
\begin{center}
\begin{tabular}{|ccc|}
\hline
\multicolumn{3}{|c|}{\textbf{local} $y_1,y_2$: \textbf{integer where} $y_1$ = 0, $y_2$ = 0} \\
\parbox{4cm}{\begin{align*}
      P_1 &:: \left[ \begin{aligned}
 		l_0 &: \textbf{loop forever do } \\ 
 			& \left[ \begin{aligned}
 				l_1 &: \textbf{noncritical}\\ 
 				l_2 &: \textbf{await } y_2 = 0\\
 				l_3 &: y_1 := 1\\
 				l_4 &: \textbf{critical}\\
 				l_5 &: y_1 := 0\\
			\end{aligned} \right]
		\end{aligned} \right]\\
   \end{align*}}
   &
	$\Bigg{\|}$   
   &
   \parbox{4cm}{\begin{align*}
      P_2 &:: \left[ \begin{aligned}
 		m_0 &: \textbf{loop forever do } \\ 
 			& \left[ \begin{aligned}
 				m_1 &: \textbf{noncritical}\\ 
 				m_2 &: \textbf{await } y_1 = 0\\
 				m_3 &: y_2 := 1\\
 				m_4 &: \textbf{critical}\\
 				m_5 &: y_2 := 0\\
			\end{aligned} \right]
		\end{aligned} \right]\\
   \end{align*}}\\
   \multicolumn{3}{|c|}{Program TRY-MUX1(proposed solution to mutual exclusion).} \\\hline
\end{tabular}
\end{center}


\textit{\textbf{a)} Is program TRY-MUXI a good solution to the mutual-exclusion problem?}
No, because it does not satisfy neither the exclusion requirement, neither the accessibility requirement. First of all there exists a computation where a state $\pi = \{l_4,m_4\}$ is accessible as shown by the following computation:
\begin{align*}
\langle \pi:\{l_0,m_0\},y_1:0,y_2:0 \rangle & \xrightarrow{l_0} \langle \pi:\{l_1,m_0\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{l_1} \langle \pi:\{l_2,m_0\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{l_2} \langle \pi:\{l_3,m_0\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{m_0} \langle \pi:\{l_3,m_1\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{m_1} \langle \pi:\{l_3,m_2\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{m_2} \langle \pi:\{l_3,m_3\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{l_3} \langle \pi:\{l_4,m_3\},y_1:1,y_2:0 \rangle\\
& \xrightarrow{m_3} \langle \pi:\{l_4,m_4\},y_1:1,y_2:1 \rangle\\
\end{align*}
Furthermore $P_2$ can indefinitely wain in $m_2$: in fact, $P_1$ is allowed to visit locations $l_3$ and $l_5$, disabling and enabling respectively the statement in $m_2$. Without a compassion requirement, it has not to be taken eventually.

\medskip
\textit{\textbf{b)} The same questions for TRY-MUX2, a version of program TRY-MUXl in which statements $l_2$ and $l_3$ are interchanged and so are statements $m_2$ and $m_3$.}

In this case, program TRY-MUX2 guarantees exclusion but not accessibility since there is a deadlock computation:
\begin{align*}
\langle \pi:\{l_0,m_0\},y_1:0,y_2:0 \rangle & \xrightarrow{l_0} \langle \pi:\{l_1,m_0\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{l_1} \langle \pi:\{l_2,m_0\},y_1:0,y_2:0 \rangle\\
& \xrightarrow{l_2} \langle \pi:\{l_3,m_0\},y_1:1,y_2:0 \rangle\\
& \xrightarrow{m_0} \langle \pi:\{l_3,m_1\},y_1:1,y_2:0 \rangle\\
& \xrightarrow{m_1} \langle \pi:\{l_3,m_2\},y_1:1,y_2:0 \rangle\\
& \xrightarrow{m_2} \langle \pi:\{l_3,m_3\},y_1:1,y_2:1 \rangle \not\rightarrow\\
\end{align*}

\medskip
\begin{center}
\begin{tabular}{|ccc|}
\hline
\multicolumn{3}{|c|}{\textbf{local} $t$: \textbf{integer where} $t$ = 1} \\
\parbox{4cm}{\begin{align*}
      P_1 &:: \left[ \begin{aligned}
 		l_0 &: \textbf{loop forever do } \\ 
 			& \left[ \begin{aligned}
 				l_1 &: \textbf{noncritical}\\ 
 				l_2 &: \textbf{await } t = 1\\
 				l_3 &: \textbf{critical}\\
 				l_4 &: t := 2\\
			\end{aligned} \right]
		\end{aligned} \right]\\
   \end{align*}}
   &
	$\Bigg{\|}$   
   &
   \parbox{4cm}{\begin{align*}
      P_2 &:: \left[ \begin{aligned}
 		m_0 &: \textbf{loop forever do } \\ 
 			& \left[ \begin{aligned}
 				m_1 &: \textbf{noncritical}\\ 
 				m_2 &: \textbf{await } t = 2\\
 				m_3 &: \textbf{critical}\\
 				m_4 &: t := 1\\
			\end{aligned} \right]
		\end{aligned} \right]\\
   \end{align*}}\\
   \multicolumn{3}{|c|}{Program TURN (turn taking).} \\\hline
\end{tabular}
\end{center}
\textit{\textbf{c)} The same questions for program TURN.}

This program satisfies exclusion but neither accessibility nor common accessibility.
\begin{itemize}
\item[exclusion] Consider the case in which $P_1$ enter in critical section ($at_{l_3}$ we have $t=1$) so $P_2$ must be in $m_0, m1, m2$ or waiting in front of $m_2$. The same consideration can be applied when $P_2$ enters in its critical section.
\item[accessibility] $P_1$ and $P_2$ enters in critical their section in a forced alternation: since it is not required to a non-critical section to terminate, if process $P_1$ (resp., $P_2$) is stuck in its non-critical section, $P_2$ (resp., $P_1$) waits indefinitely for its turn. If both non-critical sections are ensured to terminate, then the protocol would satisfy both requirements.
\end{itemize}


\newpage
\section{Additional exercices}
\subsection*{Esercizio1}
\textit{Dato un linguaggio $L \subseteq A^*$, dimostrare se che $L$ è un linguaggio star-free, allora $L$ è definibile nel frammento al prim'ordine di $S1S_A$, con la relazione di ordinamento $<$ e i predicati unari $Q_a$, con $a \in A$.}


\subsection*{Esercizio2}
\textit{Dimostrare che l'insieme dei linguaggi riconosciuti da automi di \buchi su alberi infiniti con insieme degli stati finali singoletto è strettamente contenuto nell'insieme dei linguaggi riconosciuti da automi di \buchi su alberi infiniti}


\subsection*{Esercizio3}
\textit{Sia $A=\{a,b\}$ e $T_1=\{t\in T^{\omega}_A:$tutti i cammini di t contengono un numero finito di occorrenze di a$\}$. $T_1$ contiene l'insieme di tutti gli alberi $t_i$, con $i\geqslant 0$, tali che $t_i$ ha un'occorrenza di a nelle posizioni $\epsilon, 1^{m_1}0,\ldots,1^{m_1}01^{m_2}0\ldots 1^{m_i}0$, con $m_1,m_2,\ldots,m_i>0$. Immaginiamo che esista un automa di \buchi $\Buchi$ con $n+1$ stati, con $n\geqslant 1$, incluso lo stato iniziale $q_0$ che occorre solo in posizione $\epsilon$ tale che $L(\A)=T_1$ e sia r un run di successo di $\A$ su $t_n$. Mostrare che deve esistere un cammino in $t_n$ contenente 3 nodi u,v e w, con $u<v<w$, tali che $r(u)=r(w)=s \in F e t_n(v)=a$.}


\subsection*{Esercizio4}
\textit{Siano $C=\{c_1,\ldots,c_m\}$ e \=c$= ( c_1,\ldots,c_m) $. Sia dato $T \subseteq T^{\omega}_A$ tale che $T=T_0 \cdot$\=c$(T_1,\ldots,T_m)^{\omega}$}


\subsection*{Esercizio5}
\textit{Dimostrare la (correttezza e completezza della) caratterizzazione di uno degli operatori di CTL (diverso da AF) quale minimo punto fisso di un’opportuna trasformazione di predicato.}


\subsection*{Esercizio6}
\textit{Dimostrare la (correttezza e completezza della) caratterizzazione di uno degli operatori di CTL (diverso da EG) quale massimo punto fisso di un’opportuna trasformazione di predicato.}



\end{document}
